
void DEF_LIB_EXPORTED placeDefenses(bool** freeCells, int nCellsWidth, int nCellsHeight, float mapWidth, float mapHeight
              , std::list<Object*> obstacles, std::list<Defense*> defenses) {

   
    float cellWidth = mapWidth / nCellsWidth;
    float cellHeight = mapHeight / nCellsHeight; 
    int maxAttemps = 1000;

    //inicializo el mapa de valores
    std::vector<std::vector<float>> MapValue(nCellsHeight, std::vector<float>(nCellsWidth));
    std::vector<std::vector<float>> MapValueFirstD(nCellsHeight, std::vector<float>(nCellsWidth));

    std::stack<Defense*> aux;
    float min= INF_F;
    int defensespoped=0;
     List<Defense*>::iterator savemin;
    for( List<Defense*>::iterator currentDefense = defenses.begin(); defensespoped!= defenses.size()-1; currentDefense++){
        if(currentDefense!= defenses.begin() && min > (*currentDefense)->range){ //Para no contar la primera defensa que es aparte
            min = (*currentDefense)->range;
            savemin = currentDefense;
        }
        if(currentDefense == defenses.end()){
            currentDefense = defenses.begin();
            aux.push(*currentDefense);
            defensespoped++;
            min = INF_F;
        }
    }
    for(int i = 0; i < nCellsHeight; i++){
        for(int j = 0; j < nCellsWidth; j++){
            
            MapValue[i][j] = cellValue(i, j, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, *defenses.begin());
            MapValueFirstD[i][j] = FirstDefensecellValue(i, j, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses);
           
        }
    }
    
   int row, col; //variables para obtener la fila y la columna a partir de positiontoCell
   Vector3 v;
   /*for( List<Defense*>::iterator currentDefense = defenses.begin(); currentDefense != defenses.end() && maxAttemps > 0; maxAttemps--){
        if(currentDefense == defenses.begin()) v = selection(MapValueFirstD, cellHeight, cellWidth, nCellsWidth, nCellsHeight, defenses);
        else v = selection(MapValue, cellHeight, cellWidth, nCellsWidth, nCellsHeight, defenses);
        
        positionToCell(v, row, col, cellWidth, cellHeight);
        if(feasibility((*currentDefense)->id, row, col, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses)){
            maxAttemps = 1000;
            (*currentDefense)->position = v;
            currentDefense++;
        } 
   }
   */

    bool firstdefensepositioned = false;
    while(maxAttemps > 0 && firstdefensepositioned == false){
         v = selection(MapValueFirstD, cellHeight, cellWidth, nCellsWidth, nCellsHeight, defenses);
         positionToCell(v, row, col, cellWidth, cellHeight);
        if(feasibility((*defenses.begin())->id, row, col, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses)){
            (*defenses.begin())->position = v;
            firstdefensepositioned = true;
        } 
        else maxAttemps--;
    }

    maxAttemps = 1000;
   while(!aux.empty() && maxAttemps > 0){
       v = selection(MapValue, cellHeight, cellWidth, nCellsWidth, nCellsHeight, defenses);

        positionToCell(v, row, col, cellWidth, cellHeight);
        if(feasibility(aux.top()->id, row, col, nCellsWidth, nCellsHeight, mapWidth, mapHeight, obstacles, defenses)){
            maxAttemps = 1000;
            aux.top()->position = v;
            aux.pop();
            maxAttemps = 1000;
        } 
        else maxAttemps--;
   }
   
}
